# Shall we play a game
- [Problem link from Codechef](https://www.codechef.com/problems/SWPG?tab=statement)
## Question ()
Alice and Bob play a game over 
N
N rounds, starting with an initial score of 
0
0. Alice takes the first turn.

In the 
i
t
h
i 
th
â€‹
  round (
1
â‰¤
i
â‰¤
N
1â‰¤iâ‰¤N), the current player must either add or subtract 
2
i
âˆ’
1
2 
iâˆ’1
  from the current score.

As the game progresses, let:

X
X be the maximum score reached at any point.
Y
Y be the minimum score reached at any point.
Aliceâ€™s goal is to minimize the final difference 
X
âˆ’
Y
Xâˆ’Y, while Bob aims to maximize it.

Assuming both players play optimally, determine the final value of 
X
âˆ’
Y
Xâˆ’Y after all 
N
N rounds. Since this value can be very large, output it modulo 
998244353
998244353.

Input Format
The first line of input will contain a single integer 
T
T, denoting the number of test cases.
Each test case consists a single line of input.
The only line of each test case contains an integer 
N
N â€” the number of rounds played.
Output Format
For each test case, output a single line containing one integer â€” the final value of 
X
âˆ’
Y
Xâˆ’Y modulo 
998244353
998244353.

Constraints
1
â‰¤
T
â‰¤
1
0
3
1â‰¤Tâ‰¤10 
3
 
1
â‰¤
N
â‰¤
1
0
3
1â‰¤Nâ‰¤10 
3
 
Sample 1:
Input
Output
3
1
2
10
1
3
768
Explanation:
Test Case 1: Alice increases/decreases the score by 1, so the final value of 
X
âˆ’
Y
=
1
Xâˆ’Y=1.

Test Case 2: Alice increases/decreases the score by 1. In his turn, Bob increases the score to 3 if the score after the first round is 1 or decreases it to -3, if it is -1. In either case, the final value of 
X
âˆ’
Y
Xâˆ’Y is 3.
## Explanation for the approach:
Game Recap
Rounds: There are 
ğ‘
N rounds.

Moves: In the 
ğ‘–
ith round, the player adds or subtracts 
2
ğ‘–
âˆ’
1
2 
iâˆ’1
  to the score.

Initial Score: The game starts at 0.

Track Extremes: During the game, the maximum value reached is 
ğ‘‹
X and the minimum is 
ğ‘Œ
Y. The final â€œscoreâ€ is the difference 
ğ‘‹
âˆ’
ğ‘Œ
Xâˆ’Y.

Playersâ€™ Goals:

Alice: Wants to keep 
ğ‘‹
âˆ’
ğ‘Œ
Xâˆ’Y as small as possible.

Bob: Wants to force 
ğ‘‹
âˆ’
ğ‘Œ
Xâˆ’Y to be as large as possible.

Turn Order:

Alice plays first and also on odd-numbered rounds.

Bob plays on even-numbered rounds.

Why Different Answers for Odd and Even 
ğ‘
N?
The final difference 
ğ‘‹
âˆ’
ğ‘Œ
Xâˆ’Y can be determined exactly by backward induction (i.e. analyzing the game from the last round backwards):

Odd 
ğ‘
N: Aliceâ€™s Final Move

Key Idea: When 
ğ‘
N is odd, Alice makes the last move. At that point, she can choose her move (adding or subtracting the last power of 2) so that the overall gap 
ğ‘‹
âˆ’
ğ‘Œ
Xâˆ’Y is as small as possible.

Result: With careful play throughout, it turns out that no matter what Bob did earlier, Alice can limit the final span to

ğ‘‹
âˆ’
ğ‘Œ
=
2
ğ‘
âˆ’
1
.
Xâˆ’Y=2 
Nâˆ’1
 .
Here the power 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
  is exactly the magnitude of the move in the last round. Essentially, by choosing the sign appropriately in the final round, she â€œcapsâ€ the extreme values so that the gap is only as large as the largest single move.

Even 
ğ‘
N: Bobâ€™s Final Move

Key Idea: When 
ğ‘
N is even, Bob is the one to move last. Now, Bob gets the final opportunity to â€œstretchâ€ the gap.

What Happens:

Before the last round, even with Aliceâ€™s careful play, the gap is kept relatively small (specifically, from analysis it comes out as 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
  if Alice were to move last).

On his turn, Bob can choose the move (either adding or subtracting 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
 ) so that he forces one extreme (either the maximum or the minimum) to jump further away from the other extreme.

Why a Factor of 3?

In the evenâ€‘round scenario, Bobâ€™s choice â€œaddsâ€ his moveâ€™s value to the previous gap in such a way that the new gap becomes:

ğ‘‹
âˆ’
ğ‘Œ
=
3
Ã—
2
ğ‘
âˆ’
2
.
Xâˆ’Y=3Ã—2 
Nâˆ’2
 .
Think of it this way: before the last move, the gap has been controlled to be 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
  in the best case for Alice. However, Bob can now change one extreme by an amount equal to 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
 . The careful minimax analysis (by looking at how the sequence of moves builds up the extremes) shows that this extra boost gets â€œdistributedâ€ in the final gap as a factor that converts the oddâ€‘round outcome 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
  into 
3
Ã—
2
ğ‘
âˆ’
2
3Ã—2 
Nâˆ’2
  when Bob is in control.

In simpler terms, Bobâ€™s last move â€œstretchesâ€ the gap more than Alice would allow. While Alice can restrict the range by canceling out some of the effects of previous moves, Bob is not interested in canceling â€“ heâ€™s interested in maximizing the difference. The net result, after carefully balancing all previous moves, is that the final gap in the evenâ€‘
ğ‘
N game becomes 
3
â‹…
2
ğ‘
âˆ’
2
3â‹…2 
Nâˆ’2
 .

Putting It All Together in the Code
Modular Exponentiation Function (mod_pow):
This helper function efficiently computes 
2
expo
m
o
d
â€‰
â€‰
998244353
2 
expo
 mod998244353.

When 
ğ‘
N is odd, we need 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
 .

When 
ğ‘
N is even, we need 
3
Ã—
2
ğ‘
âˆ’
2
3Ã—2 
Nâˆ’2
 .

Main Decision:

cpp
Copy
Edit
if(n % 2 == 1){
    cout << mod_pow(2, n-1) << '\n';
}
else{
    cout << (3 * mod_pow(2, n-2)) % mod << '\n';
}
Odd 
ğ‘›
n: Directly print 
2
ğ‘›
âˆ’
1
2 
nâˆ’1
  modulo the prime.

Even 
ğ‘›
n: Multiply the power 
2
ğ‘›
âˆ’
2
2 
nâˆ’2
  by 3 and take modulo.

Summary
For odd 
ğ‘
N:
Alice makes the last move and can â€œcapâ€ the maximum gap to be exactly the value of the last move, resulting in 
2
ğ‘
âˆ’
1
2 
Nâˆ’1
 .

For even 
ğ‘
N:
Bobâ€™s final move can extend the gap further, and detailed minimax analysis shows that this forces the gap to be 
3
Ã—
2
ğ‘
âˆ’
2
3Ã—2 
Nâˆ’2
 .

The multiplier of 3 appears in the evenâ€‘round scenario because Bob can always choose a move that not only uses the full power of the last move but also â€œaddsâ€ effectively to the previously built gap, leading to a final difference that is a factor 
3
/
2
3/2 times larger than what Alice could have achieved on an oddâ€‘numbered game.
## Code in cpp:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
long long mod_pow(long long base,int expo){
    long long result = 1;
    for (int i=0;i<expo;i++){
        result=(result*base)%mod;
    }
    return result;
}
int main() {
	int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        if(n%2==1){
            cout<<mod_pow(2,n-1)<<'\n';
        }
        else{
            cout<<(3*mod_pow(2,n-2))%mod<<'\n';
        }
    }
    return 0;
}
```
## Code in python:
```python
mod = 998244353
t = int(input())
for i in range(t):
    n = int(input())
    if n%2:
        r = (pow(2,n-1,mod))
    else:
        r = ((3*pow(2,n-2,mod))%mod)
    print(r)
```
