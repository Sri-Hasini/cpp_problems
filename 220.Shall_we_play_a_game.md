# Shall we play a game
- [Problem link from Codechef](https://www.codechef.com/problems/SWPG?tab=statement)
## Question (1361)
Alice and Bob play a game over N rounds, starting with an initial score of 0. Alice takes the first turn.
In the i<sup>th</sup> round (1 â‰¤ i â‰¤ N), the current player must either add or subtract 2<sup>i</sup> âˆ’ 1 from the current score.
As the game progresses, let: X be the maximum score reached at any point. Y be the minimum score reached at any point.
Aliceâ€™s goal is to minimize the final difference Xâˆ’Y, while Bob aims to maximize it.
Assuming both players play optimally, determine the final value of Xâˆ’Y after all N rounds. Since this value can be very large, output it modulo 998244353.
## Input Format
The first line of input will contain a single integer T, denoting the number of test cases.
Each test case consists a single line of input.
The only line of each test case contains an integer N â€” the number of rounds played.
## Output Format
For each test case, output a single line containing one integer â€” the final value of Xâˆ’Y modulo 998244353.
## Constraints
- 1 â‰¤ T â‰¤ 10<sup>3</sup>
- 1 â‰¤ N â‰¤ 10<sup>3</sup> 
## Sample 1:
<table>
	<tr>
		<th>Input</th>
		<th>Output</th>
	</tr>
	<tr>
		<td>3<br>1<br>2<br>10</td>
		<td>1<br>3<br>768<br></td>
	</tr>
</table>

## Explanation:
- Test Case 1: Alice increases/decreases the score by 1, so the final value of Xâˆ’Y=1.
- Test Case 2: Alice increases/decreases the score by 1. In his turn, Bob increases the score to 3 if the score after the first round is 1 or decreases it to -3, if it is -1. In either case, the final value of Xâˆ’Y is 3.
## Explanation for the approach:
### Game Recap
- Rounds: There are N rounds.
- Moves: In the i<sup>th</sup> round, the player adds or subtracts 2<sup>i</sup> âˆ’ 1 to the score.
- Initial Score: The game starts at 0.
- Track Extremes: During the game, the maximum value reached is X and the minimum is Y. The final â€œscoreâ€ is the difference X âˆ’ Y.
### Playersâ€™ Goals:
- Alice: Wants to keep X âˆ’ Y as small as possible.
- Bob: Wants to force X âˆ’ Y to be as large as possible.
### Turn Order:
- Alice plays first and also on odd-numbered rounds.
- Bob plays on even-numbered rounds.
### Why Different Answers for Odd and Even N?
The final difference X âˆ’ Y can be determined exactly by backward induction (i.e. analyzing the game from the last round backwards):
#### Odd N: Aliceâ€™s Final Move
- Key Idea: When N is odd, Alice makes the last move. At that point, she can choose her move (adding or subtracting the last power of 2) so that the overall gap X âˆ’ Y is as small as possible.
- Result: With careful play throughout, it turns out that no matter what Bob did earlier, Alice can limit the final span to X âˆ’ Y = 2<sup>*N âˆ’ 1*</sup>.
Here the power 2<sup>*Nâˆ’1*</sup> is exactly the magnitude of the move in the last round. Essentially, by choosing the sign appropriately in the final round, she â€œcapsâ€ the extreme values so that the gap is only as large as the largest single move.
#### Even N: Bobâ€™s Final Move
- Key Idea: When N is even, Bob is the one to move last. Now, Bob gets the final opportunity to â€œstretchâ€ the gap.
- What Happens: Before the last round, even with Aliceâ€™s careful play, the gap is kept relatively small (specifically, from analysis it comes out as 2<sup>*N âˆ’ 1*</sup> if Alice were to move last).
- On his turn, Bob can choose the move (either adding or subtracting 2<sup>*N âˆ’ 1*</sup>) so that he forces one extreme (either the maximum or the minimum) to jump further away from the other extreme.
### Why a Factor of 3?
- In the evenâ€‘round scenario, Bobâ€™s choice â€œaddsâ€ his moveâ€™s value to the previous gap in such a way that the new gap becomes: X âˆ’ Y = 3 Ã— 2<sup>*N âˆ’ 2*</sup>.
- Think of it this way: before the last move, the gap has been controlled to be 2<sup>*N âˆ’ 1*</sup> in the best case for Alice. However, Bob can now change one extreme by an amount equal to 2<sup>*N âˆ’ 1*</sup>.
- The careful minimax analysis (by looking at how the sequence of moves builds up the extremes) shows that this extra boost gets â€œdistributedâ€ in the final gap as a factor that converts the oddâ€‘round outcome 2<sup>*N âˆ’ 1*</sup> into 3 Ã— 2<sup>*N âˆ’ 2*</sup> when Bob is in control.
- In simpler terms, Bobâ€™s last move â€œstretchesâ€ the gap more than Alice would allow.
- While Alice can restrict the range by canceling out some of the effects of previous moves, Bob is not interested in canceling â€“> heâ€™s interested in maximizing the difference.
- The net result, after carefully balancing all previous moves, is that the final gap in the evenâ€‘N game becomes 3 Ã— 2<sup>*N âˆ’ 2*</sup>.
- Putting It All Together in the Code
### Modular Exponentiation Function (mod_pow):
- This helper function efficiently computes 2 expo mod 998244353.
- When N is odd, we need 2<sup>*N âˆ’ 1*</sup>.
- When N is even, we need 3 Ã— 2<sup>*N âˆ’ 2*</sup>.
### Main Decision:
```cpp
if(n % 2 == 1){
    cout << mod_pow(2, n-1) << '\n';
}
else{
    cout << (3 * mod_pow(2, n-2)) % mod << '\n';
}
```
##### Odd ğ‘›: 
Directly print 2<sup>*N âˆ’ 1*</sup> modulo the prime.
##### Even ğ‘›: 
Multiply the power 2<sup>*N âˆ’ 2*</sup> by 3 and take modulo.
### Summary
**1. For odd ğ‘:** <br>

	- Alice makes the last move and can â€œcapâ€ the maximum gap to be exactly the value of the last move, resulting in 2<sup>*N âˆ’ 1*</sup>.<br>
**2. For even ğ‘:** <br>

	- Bobâ€™s final move can extend the gap further, and detailed minimax analysis shows that this forces the gap to be 3 x 2<sup>*N âˆ’ 2*</sup>.
- The multiplier of 3 appears in the evenâ€‘round scenario because Bob can always choose a move that not only uses the full power of the last move but also â€œaddsâ€ effectively to the previously built gap, leading to a final difference that is a factor 3/2 times larger than what Alice could have achieved on an oddâ€‘numbered game.
## Code in cpp:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
long long mod_pow(long long base,int expo){
    long long result = 1;
    for (int i=0;i<expo;i++){
        result=(result*base)%mod;
    }
    return result;
}
int main() {
	int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        if(n%2==1){
            cout<<mod_pow(2,n-1)<<'\n';
        }
        else{
            cout<<(3*mod_pow(2,n-2))%mod<<'\n';
        }
    }
    return 0;
}
```
## Code in python:
```python
mod = 998244353
t = int(input())
for i in range(t):
    n = int(input())
    if n%2:
        r = (pow(2,n-1,mod))
    else:
        r = ((3*pow(2,n-2,mod))%mod)
    print(r)
```
