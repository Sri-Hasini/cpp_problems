# **Longest subarray with sum k**
- [Problem link from GfG](https://www.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-sub-array-with-sum-k)
- [Explanation link from TUF](https://takeuforward.org/data-structure/longest-subarray-with-given-sum-k/)
- [Explanation link from GFG](https://www.geeksforgeeks.org/longest-sub-array-sum-k/)
  
## *Medium &nbsp;&nbsp;&nbsp; Accuracy(24%)*
## **Question**
Given an array arr[] containing integers and an integer k, your task is to find the length of the longest subarray where the sum of its elements is equal to the given value k. If there is no subarray with sum equal to k, return 0.

## **Approaches**
1. **[Naive Approach] Using Nested Loop – O(n^2) Time and O(1) Space** :
- The idea is to check the sum of all the subarrays and return the length of the longest subarray having the sum k.

2. **[Expected Approach] Using Hash Map and Prefix Sum – O(n) Time and O(n) Space** :
- If you take a closer look at this problem, this is mainly an extension of Longest Subarray with 0 sum.
- The idea is based on the fact that if Sj – Si = k (where Si and Sj are prefix sums till index i and j respectively, and  i < j), then the subarray between i+1 to j has sum equal to k. 
- For example, arr[] = [5, 2, -3, 4, 7] and k = 3.  The value of S3 – S0= 3,  it means the subarray from index 1 to 3 has sum equals to 3. 
- So we mainly compute prefix sums in the array and store these prefix sums in a hash table. And check if current prefix sum – k is already present. If current prefix sum – k is present in the hash table and is mapped to index j, then subarray from j to current index has sum equal to k.

- Below are the main points to consider in your implementation.
  - If we have the whole prefix having sum equal to k, we should prefer it as it would be the longest possible till that point.
  - If there are multiple occurrences of a prefixSum, we must store index of the earliest occurrence of prefixSum because we need to find the longest subarray.

```cpp
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    int longestSubarray(vector<int>& arr, int k) {
        int n = arr.size();
        vector <int> prefix(n);
        prefix[0] = arr[0];
        int maxLen = 0;
        map <int, int> m;
        if (k == prefix[0]) maxLen = 1;
        m[prefix[0]] = 0;
        for (int i = 1; i < n; i++) {
            prefix[i] = arr[i] + prefix[i - 1];
            if (prefix[i] == k) {//if it is equal then we know that upto that index that subarray satisfies
                maxLen = max(maxLen, i + 1);
            }
            //if prefixsum - k exists in the map then there exist such  subarray from (i - m[prefix[i] - k])
            else if (m.find(prefix[i] - k) != m.end()) {
                maxLen = max(maxLen, abs(i - m[prefix[i] - k]));
            }
            if (m.find(prefix[i]) == m.end()) {
                m[prefix[i]] = i;//store only first occurance index of prefixx sum
            }
        }
        return maxLen;
    }
};

//{ Driver Code Starts.

int main() {
    int t;
    cin >> t;
    cin.ignore(); // Ignore newline character after t

    while (t--) {
        vector<int> arr;
        int k;
        string inputLine;

        getline(cin, inputLine); // Read the array input as a line
        stringstream ss(inputLine);
        int value;
        while (ss >> value) {
            arr.push_back(value);
        }

        cin >> k;
        cin.ignore(); // Ignore newline character after k input

        Solution solution;
        cout << solution.longestSubarray(arr, k) << "\n";
        cout << "~\n";
    }

    return 0;
}

// } Driver Code Ends
